import{i as O,e as P}from"./memoryEstimations-s89CRICA.js";const F=2;let G=class E{constructor(t=[],e=[]){this.lengths=t??[],this.coords=e??[]}static fromJSON(t){return new E(t.lengths,t.coords)}static fromRect(t){const[e,o,s,i]=t,n=s-e,h=i-o;return new E([5],[e,o,n,0,0,h,-n,0,0,-h])}get isPoint(){return this.lengths.length===0&&this.coords.length>=2}get maxLength(){return Math.max(...this.lengths)}get size(){return this.lengths.reduce((t,e)=>t+e)}get usedMemory(){return 64+O(this.lengths,this.coords)}area(){let t=0,e=0;if(!this.lengths.length)return 0;for(let o=0;o<this.lengths.length;o++){const s=this.lengths[o];if(s<3)continue;let i=this.coords[F*e],n=this.coords[F*e+1];for(let h=1;h<s;h+=1){const c=this.coords[F*(h+e)],d=this.coords[F*(h+e)+1];t+=-.5*(c-i)*(d+n),i=c,n=d}e+=s}return t}forEachVertex(t){let e=0;this.lengths.length||t(this.coords[0],this.coords[1]);for(let o=0;o<this.lengths.length;o++){const s=this.lengths[o];for(let i=0;i<s;i++)t(this.coords[F*(i+e)],this.coords[F*(i+e)+1]);e+=s}}deltaDecode(){const t=this.clone(),{coords:e,lengths:o}=t;let s=0;for(const i of o){for(let n=1;n<i;n++)e[2*(s+n)]+=e[2*(s+n)-2],e[2*(s+n)+1]+=e[2*(s+n)-1];s+=i}return t}clone(t){if(this.lengths.length===0)return new E([],[this.coords[0],this.coords[1]]);const e=(this.lengths.length===0?1:this.lengths.reduce((s,i)=>s+i))*F,o=this.coords.slice(0,e);return t?(t.set(o),new E(this.lengths,t)):new E(Array.from(this.lengths),Array.from(o))}};function V(r,t){return r?t?4:3:t?3:2}function S(r,t,e,o){if(!(t!=null&&t.lengths.length))return null;r.lengths.length&&(r.lengths.length=0),r.coords.length&&(r.coords.length=0);const s=r.coords,i=[],n=e?[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY]:[Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY,Number.NEGATIVE_INFINITY],{lengths:h,coords:c}=t,d=V(e,o);let m=0;for(const l of h){const u=j(n,c,m,l,e,o);u&&i.push(u),m+=l*d}if(i.sort((l,u)=>{let I=l[2]-u[2];return I===0&&e&&(I=l[4]-u[4]),I}),i.length){let l=6*i[0][2];s[0]=i[0][0]/l,s[1]=i[0][1]/l,e&&(l=6*i[0][4],s[2]=l!==0?i[0][3]/l:0),(s[0]<n[0]||s[0]>n[1]||s[1]<n[2]||s[1]>n[3]||e&&(s[2]<n[4]||s[2]>n[5]))&&(s.length=0)}if(!s.length){const l=t.lengths[0]?x(c,0,h[0],e,o):null;if(!l)return null;s[0]=l[0],s[1]=l[1],e&&l.length>2&&(s[2]=l[2])}return r}function j(r,t,e,o,s,i){const n=V(s,i);let h=e,c=e+n,d=0,m=0,l=0,u=0,I=0;for(let b=0,w=o-1;b<w;b++,h+=n,c+=n){const a=t[h],g=t[h+1],N=t[h+2],f=t[c],y=t[c+1],M=t[c+2];let p=a*y-f*g;u+=p,d+=(a+f)*p,m+=(g+y)*p,s&&(p=a*M-f*N,l+=(N+M)*p,I+=p),a<r[0]&&(r[0]=a),a>r[1]&&(r[1]=a),g<r[2]&&(r[2]=g),g>r[3]&&(r[3]=g),s&&(N<r[4]&&(r[4]=N),N>r[5]&&(r[5]=N))}if(u>0&&(u*=-1),I>0&&(I*=-1),!u)return null;const T=[d,m,.5*u];return s&&(T[3]=l,T[4]=.5*I),T}function x(r,t,e,o,s){const i=V(o,s);let n=t,h=t+i,c=0,d=0,m=0,l=0;for(let u=0,I=e-1;u<I;u++,n+=i,h+=i){const T=r[n],b=r[n+1],w=r[n+2],a=r[h],g=r[h+1],N=r[h+2],f=o?$(T,b,w,a,g,N):A(T,b,a,g);if(f)if(c+=f,o){const y=L(T,b,w,a,g,N);d+=f*y[0],m+=f*y[1],l+=f*y[2]}else{const y=J(T,b,a,g);d+=f*y[0],m+=f*y[1]}}return c>0?o?[d/c,m/c,l/c]:[d/c,m/c]:e>0?o?[r[t],r[t+1],r[t+2]]:[r[t],r[t+1]]:null}function A(r,t,e,o){const s=e-r,i=o-t;return Math.sqrt(s*s+i*i)}function $(r,t,e,o,s,i){const n=o-r,h=s-t,c=i-e;return Math.sqrt(n*n+h*h+c*c)}function J(r,t,e,o){return[r+.5*(e-r),t+.5*(o-t)]}function L(r,t,e,o,s,i){return[r+.5*(o-r),t+.5*(s-t),e+.5*(i-e)]}class q{constructor(t=null,e={},o,s,i=0){this.geometry=t,this.attributes=e,this.centroid=o,this.objectId=s,this.displayId=i}static fromJSON(t){const e=t.geometry?G.fromJSON(t.geometry):null,o=t.centroid?G.fromJSON(t.centroid):null,s=t.objectId;return new q(e,t.attributes,o,s)}weakClone(){const t=new q(this.geometry,this.attributes,this.centroid,this.objectId);return t.displayId=this.displayId,t}clone(){var o,s;const t=(o=this.geometry)==null?void 0:o.clone(),e=new q(t,{...this.attributes},(s=this.centroid)==null?void 0:s.clone(),this.objectId);return e.displayId=this.displayId,e}ensureCentroid(t){return this.centroid??(this.centroid=S(new G,this.geometry,t.hasZ,t.hasM)),this.centroid}get usedMemory(){var t;return 128+P(this.attributes)+(((t=this.geometry)==null?void 0:t.usedMemory)??0)}}function Z(r){var t,e;return!!((e=(t=r.geometry)==null?void 0:t.coords)!=null&&e.length)}class Y{constructor(){this.objectIdFieldName=null,this.globalIdFieldName=null,this.geohashFieldName=null,this.geometryProperties=null,this.geometryType=null,this.spatialReference=null,this.hasZ=!1,this.hasM=!1,this.features=[],this.fields=[],this.transform=null,this.exceededTransferLimit=!1,this.uniqueIdField=null,this.queryGeometryType=null,this.queryGeometry=null}weakClone(){const t=new Y;return t.objectIdFieldName=this.objectIdFieldName,t.globalIdFieldName=this.globalIdFieldName,t.geohashFieldName=this.geohashFieldName,t.geometryProperties=this.geometryProperties,t.geometryType=this.geometryType,t.spatialReference=this.spatialReference,t.hasZ=this.hasZ,t.hasM=this.hasM,t.features=this.features,t.fields=this.fields,t.transform=this.transform,t.exceededTransferLimit=this.exceededTransferLimit,t.uniqueIdField=this.uniqueIdField,t.queryGeometry=this.queryGeometry,t.queryGeometryType=this.queryGeometryType,t}}export{Y as a,G as e,S as n,Z as o,q as s};
