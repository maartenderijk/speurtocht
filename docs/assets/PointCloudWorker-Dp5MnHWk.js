import{G as s,H as f,I as g,S as x,c8 as ee,c9 as q,a as b,jW as ie,f_ as te,aS as oe,m6 as W,m7 as se,m8 as le,b4 as ne,af as Y,ac as ae,hb as ue}from"./index-CRroVR8n.js";import{O as pe}from"./quat-BhKT9Uif.js";import{e as de}from"./quatf64-aQ5IuZRd.js";import{t as Z,n as H}from"./vec3f32-nZdmKIgz.js";import{w as ce,l as fe,c as ye,I as he}from"./I3SBinaryReader-BZB8yY8k.js";import{I as be}from"./orientedBoundingBox-05ok6JGR.js";var N;let R=N=class extends x{constructor(){super(...arguments),this.field=null,this.minValue=0,this.maxValue=255}clone(){return new N({field:this.field,minValue:this.minValue,maxValue:this.maxValue})}};s([f({type:String,json:{write:{isRequired:!0}}})],R.prototype,"field",void 0),s([f({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}})],R.prototype,"minValue",void 0),s([f({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}})],R.prototype,"maxValue",void 0),R=N=s([g("esri.renderers.support.pointCloud.ColorModulation")],R);const me=R,D=new ee({pointCloudFixedSizeAlgorithm:"fixed-size",pointCloudSplatAlgorithm:"splat"});let z=class extends x{};s([f({type:D.apiValues,readOnly:!0,nonNullable:!0,json:{type:D.jsonValues,read:!1,write:{writer:D.write,isRequired:!0}}})],z.prototype,"type",void 0),z=s([g("esri.renderers.support.pointCloud.PointSizeAlgorithm")],z);const G=z;var B;let I=B=class extends G{constructor(){super(...arguments),this.type="fixed-size",this.size=0,this.useRealWorldSymbolSizes=null}clone(){return new B({size:this.size,useRealWorldSymbolSizes:this.useRealWorldSymbolSizes})}};s([q({pointCloudFixedSizeAlgorithm:"fixed-size"})],I.prototype,"type",void 0),s([f({type:Number,nonNullable:!0,json:{write:{isRequired:!0}}})],I.prototype,"size",void 0),s([f({type:Boolean,json:{write:!0}})],I.prototype,"useRealWorldSymbolSizes",void 0),I=B=s([g("esri.renderers.support.pointCloud.PointSizeFixedSizeAlgorithm")],I);const ve=I;var P;let j=P=class extends G{constructor(){super(...arguments),this.type="splat",this.scaleFactor=1}clone(){return new P({scaleFactor:this.scaleFactor})}};s([q({pointCloudSplatAlgorithm:"splat"})],j.prototype,"type",void 0),s([f({type:Number,value:1,nonNullable:!0,json:{write:{isRequired:!0}}})],j.prototype,"scaleFactor",void 0),j=P=s([g("esri.renderers.support.pointCloud.PointSizeSplatAlgorithm")],j);const ge=j,we={key:"type",base:G,typeMap:{"fixed-size":ve,splat:ge}},M=ie()({pointCloudClassBreaksRenderer:"point-cloud-class-breaks",pointCloudRGBRenderer:"point-cloud-rgb",pointCloudStretchRenderer:"point-cloud-stretch",pointCloudUniqueValueRenderer:"point-cloud-unique-value"});let w=class extends x{constructor(e){super(e),this.type=void 0,this.pointSizeAlgorithm=null,this.colorModulation=null,this.pointsPerInch=10}clone(){return console.warn(".clone() is not implemented for "+this.declaredClass),null}cloneProperties(){return{pointSizeAlgorithm:b(this.pointSizeAlgorithm),colorModulation:b(this.colorModulation),pointsPerInch:b(this.pointsPerInch)}}};s([f({type:M.apiValues,readOnly:!0,nonNullable:!0,json:{type:M.jsonValues,read:!1,write:{writer:M.write,isRequired:!0}}})],w.prototype,"type",void 0),s([f({types:we,json:{write:!0}})],w.prototype,"pointSizeAlgorithm",void 0),s([f({type:me,json:{write:!0}})],w.prototype,"colorModulation",void 0),s([f({json:{write:!0},nonNullable:!0,type:Number})],w.prototype,"pointsPerInch",void 0),w=s([g("esri.renderers.PointCloudRenderer")],w),function(i){i.fieldTransformTypeKebabDict=new ee({none:"none",lowFourBit:"low-four-bit",highFourBit:"high-four-bit",absoluteValue:"absolute-value",moduloTen:"modulo-ten"})}(w||(w={}));const m=w;var F;let T=F=class extends x{constructor(){super(...arguments),this.description=null,this.label=null,this.minValue=0,this.maxValue=0,this.color=null}clone(){return new F({description:this.description,label:this.label,minValue:this.minValue,maxValue:this.maxValue,color:b(this.color)})}};s([f({type:String,json:{write:!0}})],T.prototype,"description",void 0),s([f({type:String,json:{write:!0}})],T.prototype,"label",void 0),s([f({type:Number,json:{read:{source:"classMinValue"},write:{target:"classMinValue",isRequired:!0}}})],T.prototype,"minValue",void 0),s([f({type:Number,json:{read:{source:"classMaxValue"},write:{target:"classMaxValue",isRequired:!0}}})],T.prototype,"maxValue",void 0),s([f({type:oe,json:{type:[te],write:{isRequired:!0}}})],T.prototype,"color",void 0),T=F=s([g("esri.renderers.support.pointCloud.ColorClassBreakInfo")],T);const Te=T;var U;let S=U=class extends m{constructor(i){super(i),this.type="point-cloud-class-breaks",this.field=null,this.legendOptions=null,this.fieldTransformType=null,this.colorClassBreakInfos=null}clone(){return new U({...this.cloneProperties(),field:this.field,fieldTransformType:this.fieldTransformType,colorClassBreakInfos:b(this.colorClassBreakInfos),legendOptions:b(this.legendOptions)})}};s([q({pointCloudClassBreaksRenderer:"point-cloud-class-breaks"})],S.prototype,"type",void 0),s([f({json:{write:{isRequired:!0}},type:String})],S.prototype,"field",void 0),s([f({type:W,json:{write:!0}})],S.prototype,"legendOptions",void 0),s([f({type:m.fieldTransformTypeKebabDict.apiValues,json:{type:m.fieldTransformTypeKebabDict.jsonValues,read:m.fieldTransformTypeKebabDict.read,write:m.fieldTransformTypeKebabDict.write}})],S.prototype,"fieldTransformType",void 0),s([f({type:[Te],json:{write:{isRequired:!0}}})],S.prototype,"colorClassBreakInfos",void 0),S=U=s([g("esri.renderers.PointCloudClassBreaksRenderer")],S);const Se=S;var K;let V=K=class extends m{constructor(i){super(i),this.type="point-cloud-stretch",this.field=null,this.legendOptions=null,this.fieldTransformType=null,this.stops=null}clone(){return new K({...this.cloneProperties(),field:b(this.field),fieldTransformType:b(this.fieldTransformType),stops:b(this.stops),legendOptions:b(this.legendOptions)})}};s([q({pointCloudStretchRenderer:"point-cloud-stretch"})],V.prototype,"type",void 0),s([f({json:{write:{isRequired:!0}},type:String})],V.prototype,"field",void 0),s([f({type:W,json:{write:!0}})],V.prototype,"legendOptions",void 0),s([f({type:m.fieldTransformTypeKebabDict.apiValues,json:{type:m.fieldTransformTypeKebabDict.jsonValues,read:m.fieldTransformTypeKebabDict.read,write:m.fieldTransformTypeKebabDict.write}})],V.prototype,"fieldTransformType",void 0),s([f({type:[se],json:{write:{isRequired:!0}}})],V.prototype,"stops",void 0),V=K=s([g("esri.renderers.PointCloudStretchRenderer")],V);const Ve=V;var J;let $=J=class extends x{constructor(){super(...arguments),this.description=null,this.label=null,this.values=null,this.color=null}clone(){return new J({description:this.description,label:this.label,values:b(this.values),color:b(this.color)})}};s([f({type:String,json:{write:!0}})],$.prototype,"description",void 0),s([f({type:String,json:{write:!0}})],$.prototype,"label",void 0),s([f({type:[String],json:{write:{isRequired:!0}}})],$.prototype,"values",void 0),s([f({type:oe,json:{type:[te],write:{isRequired:!0}}})],$.prototype,"color",void 0),$=J=s([g("esri.renderers.support.pointCloud.ColorUniqueValueInfo")],$);const Ce=$;var _;let C=_=class extends m{constructor(i){super(i),this.type="point-cloud-unique-value",this.field=null,this.fieldTransformType=null,this.colorUniqueValueInfos=null,this.legendOptions=null}clone(){return new _({...this.cloneProperties(),field:b(this.field),fieldTransformType:b(this.fieldTransformType),colorUniqueValueInfos:b(this.colorUniqueValueInfos),legendOptions:b(this.legendOptions)})}};s([q({pointCloudUniqueValueRenderer:"point-cloud-unique-value"})],C.prototype,"type",void 0),s([f({json:{write:{isRequired:!0}},type:String})],C.prototype,"field",void 0),s([f({type:m.fieldTransformTypeKebabDict.apiValues,json:{type:m.fieldTransformTypeKebabDict.jsonValues,read:m.fieldTransformTypeKebabDict.read,write:m.fieldTransformTypeKebabDict.write}})],C.prototype,"fieldTransformType",void 0),s([f({type:[Ce],json:{write:{isRequired:!0}}})],C.prototype,"colorUniqueValueInfos",void 0),s([f({type:W,json:{write:!0}})],C.prototype,"legendOptions",void 0),C=_=s([g("esri.renderers.PointCloudUniqueValueRenderer")],C);const $e=C;function Re(i,e,n,l){const{rendererJSON:d,isRGBRenderer:h}=i;let o=null,a=null;if(e&&h)o=e;else if(e&&(d==null?void 0:d.type)==="pointCloudUniqueValueRenderer"){a=$e.fromJSON(d);const t=a.colorUniqueValueInfos;o=new Uint8Array(3*l);const c=k(a.fieldTransformType);for(let r=0;r<l;r++){const u=(c?c(e[r]):e[r])+"";for(let p=0;p<t.length;p++)if(t[p].values.includes(u)){o[3*r]=t[p].color.r,o[3*r+1]=t[p].color.g,o[3*r+2]=t[p].color.b;break}}}else if(e&&(d==null?void 0:d.type)==="pointCloudStretchRenderer"){a=Ve.fromJSON(d);const t=a.stops;o=new Uint8Array(3*l);const c=k(a.fieldTransformType);for(let r=0;r<l;r++){const u=c?c(e[r]):e[r],p=t.length-1;if(u<t[0].value)o[3*r]=t[0].color.r,o[3*r+1]=t[0].color.g,o[3*r+2]=t[0].color.b;else if(u>=t[p].value)o[3*r]=t[p].color.r,o[3*r+1]=t[p].color.g,o[3*r+2]=t[p].color.b;else for(let y=1;y<t.length;y++)if(u<t[y].value){const v=(u-t[y-1].value)/(t[y].value-t[y-1].value);o[3*r]=t[y].color.r*v+t[y-1].color.r*(1-v),o[3*r+1]=t[y].color.g*v+t[y-1].color.g*(1-v),o[3*r+2]=t[y].color.b*v+t[y-1].color.b*(1-v);break}}}else if(e&&(d==null?void 0:d.type)==="pointCloudClassBreaksRenderer"){a=Se.fromJSON(d);const t=a.colorClassBreakInfos;o=new Uint8Array(3*l);const c=k(a.fieldTransformType);for(let r=0;r<l;r++){const u=c?c(e[r]):e[r];for(let p=0;p<t.length;p++)if(u>=t[p].minValue&&u<=t[p].maxValue){o[3*r]=t[p].color.r,o[3*r+1]=t[p].color.g,o[3*r+2]=t[p].color.b;break}}}else o=new Uint8Array(3*l).fill(255);if(n&&(a!=null&&a.colorModulation)){const t=a.colorModulation.minValue,c=a.colorModulation.maxValue,r=.3;for(let u=0;u<l;u++){const p=n[u],y=p>=c?1:p<=t?r:r+(1-r)*(p-t)/(c-t);o[3*u]=y*o[3*u],o[3*u+1]=y*o[3*u+1],o[3*u+2]=y*o[3*u+2]}}return o}function Ie(i,e){if(i.encoding==null||i.encoding===""){const n=ce(e,i);if(n.vertexAttributes.position==null)return;const l=fe(e,n.vertexAttributes.position),d=n.header.fields,h=[d.offsetX,d.offsetY,d.offsetZ],o=[d.scaleX,d.scaleY,d.scaleZ],a=l.length/3,t=new Float64Array(3*a);for(let c=0;c<a;c++)t[3*c]=l[3*c]*o[0]+h[0],t[3*c+1]=l[3*c+1]*o[1]+h[1],t[3*c+2]=l[3*c+2]*o[2]+h[2];return t}if(i.encoding==="lepcc-xyz")return ye(e).result}function O(i,e,n){return i!=null&&i.attributeInfo.useElevation?e?je(e,n):null:i!=null&&i.attributeInfo.storageInfo?he(i.attributeInfo.storageInfo,i.buffer,n):null}function je(i,e){const n=new Float64Array(e);for(let l=0;l<e;l++)n[l]=i[3*l+2];return n}function xe(i,e,n,l,d){const h=i.length/3;let o=0;for(let a=0;a<h;a++){let t=!0;for(let c=0;c<l.length&&t;c++){const{filterJSON:r}=l[c],u=d[c].values[a];switch(r.type){case"pointCloudValueFilter":{const p=r.mode==="exclude";r.values.includes(u)===p&&(t=!1);break}case"pointCloudBitfieldFilter":{const p=L(r.requiredSetBits),y=L(r.requiredClearBits);((u&p)!==p||u&y)&&(t=!1);break}case"pointCloudReturnFilter":{const p=15&u,y=u>>>4&15,v=y>1,re=p===1,E=p===y;let X=!1;for(const A of r.includedReturns)if(A==="last"&&E||A==="firstOfMany"&&re&&v||A==="lastOfMany"&&E&&v||A==="single"&&!v){X=!0;break}X||(t=!1);break}}}t&&(n[o]=a,i[3*o]=i[3*a],i[3*o+1]=i[3*a+1],i[3*o+2]=i[3*a+2],e[3*o]=e[3*a],e[3*o+1]=e[3*a+1],e[3*o+2]=e[3*a+2],o++)}return o}function k(i){switch(i){default:case null:case"none":return e=>e;case"low-four-bit":return e=>15&e;case"high-four-bit":return e=>(240&e)>>4;case"absolute-value":return e=>Math.abs(e);case"modulo-ten":return e=>e%10}}function L(i){let e=0;for(const n of i||[])e|=1<<n;return e}class qe{transform(e){const n=this._transform(e),l=[n.points.buffer,n.rgb.buffer];n.pointIdFilterMap!=null&&l.push(n.pointIdFilterMap.buffer);for(const d of n.attributes)"buffer"in d.values&&le(d.values.buffer)&&d.values.buffer!==n.rgb.buffer&&l.push(d.values.buffer);return Promise.resolve({result:n,transferList:l})}_transform(e){const n=Ie(e.schema,e.geometryBuffer);let l=n.length/3,d=null;const h=new Array,o=O(e.primaryAttributeData,n,l);e.primaryAttributeData!=null&&o&&h.push({attributeInfo:e.primaryAttributeData.attributeInfo,values:o});const a=O(e.modulationAttributeData,n,l);e.modulationAttributeData!=null&&a&&h.push({attributeInfo:e.modulationAttributeData.attributeInfo,values:a});let t=Re(e.rendererInfo,o,a,l);if(e.filterInfo&&e.filterInfo.length>0&&e.filterAttributesData!=null){const r=e.filterAttributesData.filter(ne).map(u=>{const p=O(u,n,l),y={attributeInfo:u.attributeInfo,values:p};return h.push(y),y});d=new Uint32Array(l),l=xe(n,t,d,e.filterInfo,r)}for(const r of e.userAttributesData){const u=O(r,n,l);h.push({attributeInfo:r.attributeInfo,values:u})}3*l<t.length&&(t=new Uint8Array(t.buffer.slice(0,3*l))),Oe(n,l,e.elevationOffset);const c=Ae(n,l,be.fromData(e.obbData),Y.fromJSON(e.inSR),Y.fromJSON(e.outSR));return{obbData:e.obbData,points:c,rgb:t,attributes:h,pointIdFilterMap:d}}}function Ae(i,e,n,l,d){if(!ae(i,l,0,i,d,0,e))throw new Error("Can't reproject");const h=Z(n.center),o=H(),a=H(),t=Z(n.halfSize);pe(Q,n.quaternion);const c=new Float32Array(3*e);for(let r=0;r<e;r++){let u=3*r;o[0]=i[u]-h[0],o[1]=i[u+1]-h[1],o[2]=i[u+2]-h[2],ue(a,o,Q),t[0]=Math.max(t[0],Math.abs(a[0])),t[1]=Math.max(t[1],Math.abs(a[1])),t[2]=Math.max(t[2],Math.abs(a[2])),c[u++]=o[0],c[u++]=o[1],c[u]=o[2]}return n.halfSize=t,c}function Oe(i,e,n){if(n!==0)for(let l=0;l<e;l++)i[3*l+2]+=n}const Q=de();function ze(){return new qe}const Ke=Object.freeze(Object.defineProperty({__proto__:null,default:ze},Symbol.toStringTag,{value:"Module"}));export{Ke as P,$e as a,Ve as b,Se as c,m as d};
