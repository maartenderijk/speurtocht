import{t as H,s as le}from"./SimpleGeometryCursor-B92kdZ15.js";import{P as Q,e as O,j as ue,L as Pe,a as K,k as A,f as Ce,i as L,x as Se,z as De,A as Me,aM as oe,aN as we,b as _,aO as Ee,aP as _e,aQ as Ve,aR as Re,aS as ge,aT as Ye,n as N,K as de,E as Ae,ao as Xe,a0 as pe,c as $,w as ne,v as te,Y as Be,r as re,T as Ge,a6 as me,am as J,aU as Z,a1 as he,aV as Fe,ai as Te,aW as ze,$ as Ne,aX as Le}from"./ProjectionTransformation-wLgQojwe.js";import{eL as ve,eM as ke}from"./index-CRroVR8n.js";import{i as qe}from"./GeometryCleaner-BEJM7I4l-De88dfdp.js";class je{getOperatorType(){return 10204}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n){return new ye(e,t,s,n)}execute(e,t,s,n){return e||Q("null param is not allowed."),new ye(null,t,s,n).generalize(e)}}class ye extends H{constructor(e,t,s,n){super(),this.m_pline=null,this.m_point=new O,this.m_stack=[],this.m_resultstack=[],this.m_callCount=0,this.m_progressTracker=n,this.m_geoms=e,this.m_maxDeviation=t,this.m_bRemoveDegenerateParts=s}tock(){return!0}getRank(){return 1}next(){const e=this.m_geoms.next();return e===null?null:(ue(e),this.generalize(e))}getGeometryID(){return this.m_geoms.getGeometryID()}generalize(e){const t=e.getGeometryType();if(Pe(t))return e;if(t===K.enumEnvelope){const i=new A({vd:e.getDescription()});return i.addEnvelope(e,!1),this.generalize(i)}if(Ce(t)){const i=new L({vd:e.getDescription()});return i.addSegment(e,!0),this.generalize(i)}if(Se(t)||De(""),e.isEmpty()||this.m_maxDeviation<=0)return e;const s=new Me().execute(e,0,.05*this.m_maxDeviation,0,this.m_progressTracker);e.hasNonLinearSegments()&&(this.m_maxDeviation*=.95);const n=s,r=e.createInstance();r.getGeometryType()===K.enumPolygon&&r.setFillRule(e.getFillRule()),this.m_xy=n.getAttributeStreamRef(0);{const i={stack:[],error:void 0,hasError:!1};try{const a=new oe;this.m_pline=a,ve(i,we(()=>{this.m_pline=null},!1),!1);for(let m=0,l=n.getPathCount();m<l;m++)this.generalizePath(n.getImpl(),m,r.getImpl())}catch(a){i.error=a,i.hasError=!0}finally{ke(i)}}return this.m_resultstack.length=0,this.m_stack.length=0,r}generalizePath(e,t,s){if(e.getPathSize(t)<2)return;this.m_resultstack.length=0,this.m_stack.length=0;const n=e.getPathStart(t),r=e.getPathEnd(t)-1,i=e.isClosedPath(t),a=e.isClosedPathInXYPlane(t);let m=0,l=-1;this.m_stack.push(i?n:r),this.m_stack.push(n);let h=!1,u=!1;for(!this.m_bRemoveDegenerateParts&&a&&(h=!0,u=!0);this.m_stack.length>1;){const c=this.m_stack.at(-1);this.m_stack.pop();const d=this.m_stack.at(-1);let b=e.getXY(c);this.m_pline.setStartXY(b),b=e.getXY(d),this.m_pline.setEndXY(b);const p=[Number.NaN];let g=this.findGreatestDistance(c,d,r,p);g>=0&&(h?h=!1:(u&&p[0]>m&&(m=p[0],l=g),p[0]<=this.m_maxDeviation&&(g=-1))),g>=0?(this.m_stack.push(g),this.m_stack.push(c)):this.m_resultstack.push(c)}i||this.m_resultstack.push(this.m_stack[0]);const f=this.m_resultstack.length;if(f===e.getPathSize(t)&&f===this.m_stack.length)s.addPath(e,t,!0);else if(this.m_resultstack.length>0){if(this.m_bRemoveDegenerateParts&&this.m_resultstack.length<=2&&(i||this.m_resultstack.length===1||_.distance(e.getXY(this.m_resultstack[0]),e.getXY(this.m_resultstack[1]))<=this.m_maxDeviation))return;if(u&&l>=0&&m<=this.m_maxDeviation){const c=this.m_resultstack.at(-1)>l;this.m_resultstack.push(l),c&&(this.m_resultstack[this.m_resultstack.length-2]=Ee(this.m_resultstack[this.m_resultstack.length-1],this.m_resultstack[this.m_resultstack.length-1]=this.m_resultstack[this.m_resultstack.length-2]))}for(let c=0,d=this.m_resultstack.length;c<d;c++)e.getPointByVal(this.m_resultstack[c],this.m_point),c===0?s.startPathPoint(this.m_point):s.lineToPoint(this.m_point);if(i){for(let c=this.m_resultstack.length;c<3;c++)s.lineToPoint(this.m_point);s.closePathWithLine()}}}findGreatestDistance(e,t,s,n){let r=t-1;t<=e&&(r=s);let i=-1,a=0;const m=new _;for(let l=e+1;l<=r;l++){this.m_xy.queryPoint2D(2*l,m);const h=m.x,u=m.y,f=this.m_pline.getClosestCoordinate(m,!1);m.assign(this.m_pline.getCoord2D(f)),m.x-=h,m.y-=u;const c=m.length();c>a&&(i=l,a=c),this.m_callCount++}return n[0]=a,i}}class Oe{getOperatorType(){return 10104}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}isSimple(e,t,s,n,r){return Fe(e,t,s,n,r)===5}executeMany(e,t,s,n){return new Ue(e,t,s,n)}execute(e,t,s,n){const r=new le([e]),i=this.executeMany(r,t,s,n).next();return i||$("null output"),i}}class Ue extends H{constructor(e,t,s,n){super(),e||Q(""),this.m_progressTracker=n,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=e,this.m_spatialReference=t}next(){const e=this.m_inputGeometryCursor.next();return e?(ue(e),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(e)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(e){return e||Q(""),ze(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}var P;function z(o,e,t,s,n,r){return{m_from:o.clone(),m_to:e.clone(),m_center:t.clone(),m_next:n,m_type:s}}function se(o,e,t,s,n){return{m_from:o.clone(),m_to:e.clone(),m_next:t,m_type:4,m_center:new _}}(function(o){o[o.enumDummy=256]="enumDummy",o[o.enumLine=1]="enumLine",o[o.enumArc=2]="enumArc",o[o.enumMiter=8]="enumMiter",o[o.enumBevel=16]="enumBevel",o[o.enumJoinMask=26]="enumJoinMask",o[o.enumConnectionMask=27]="enumConnectionMask"})(P||(P={}));class Je extends H{constructor(e,t,s,n,r,i,a,m,l,h){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=h,this.m_parent=e,this.m_mp=t,this.m_distance=s,this.m_spatialReference=n,this.m_densifyDist=m,this.m_maxVertexInCompleteCircle=l,this.m_joins=r,this.m_caps=i,this.m_miterLimit=a}next(){const e=new O;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(this.m_caps===1)return this.m_index=this.m_mp.getPointCount(),new A({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,s=!1;if(this.m_bufferedPolygon===null&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){const n=new he,r=e.getX()-this.m_x,i=e.getY()-this.m_y;n.setShiftCoords(r,i),t.applyTransformation(n)}return Te(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class We extends H{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;const e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){const s=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(s)){let r=e.getXY(e.getPathEnd(s)-1);for(;this.m_currentPathIndex<e.getPathCount();){const i=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex)||!i.equals(r))break;r=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(s===0&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const r=this.m_polyline;return this.m_polyline=null,r}const n=new L({vd:this.m_polyline.getDescription()});n.addPath(this.m_polyline,s,!0);for(let r=s+1;r<this.m_currentPathIndex;r++)n.addSegmentsFromPath(this.m_polyline,r,0,e.getSegmentCountPath(r),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),n}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Ke extends H{constructor(e,t,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=s}next(){if(this.m_geometry===null&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){const t=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,t,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Qe extends H{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){const e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){const t=this.m_index,s=e.calculateRingArea2D(this.m_index);for(J(s>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;let n;return n=t===0&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index),n}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class He{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=K.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new _e(0,0),this.m_smallTolerance=new _e(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new oe,this.m_helperLine2=new oe,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=Ve.constructDefault(e),this.m_progressTracker=e}buffer(e,t,s,n,r,i,a,m){if(e||Q("Geometry.Bufferer.Impl.Buffer"),a<0&&Q("Geometry.Bufferer.Impl.Buffer"),Re(e.getGeometryType())&&De("Unsupported geometry type."),e.isEmpty())return new A({vd:e.getDescription()});if(this.m_joins=n,this.m_caps=r,this.m_bRoundBuffer=!1,this.m_miterLimit=i,this.m_originalGeomType=e.getGeometryType(),ge(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_joins===0:Pe(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_caps===0:Ye(this.m_originalGeomType)&&(this.m_bRoundBuffer=this.m_joins===0&&this.m_caps===0),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=qe(e),this.m_geometry.isEmpty())return new A({vd:e.getDescription()});const l=new N;this.m_geometry.queryLooseEnvelope(l),t>0&&l.inflateCoords(t,t),this.m_tolerance=de(s,l,!0),this.m_smallTolerance=de(null,l,!0),m<=0&&(m=96),this.m_spatialReference=s,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=this.m_absDistance!==0?1/this.m_absDistance:0,Number.isNaN(a)||a===0?a=1e-5*this.m_absDistance:a>.5*this.m_absDistance&&(a=.5*this.m_absDistance),m<12&&(m=12);const h=Math.abs(t)*(1-Math.cos(Math.PI/m));if(h>a)a=h;else if(t!==0){const f=Math.PI/Math.acos(1-a/Math.abs(t));f<m-1&&(m=Math.trunc(f))<12&&(m=12,a=Math.abs(t)*(1-Math.cos(Math.PI/m)))}this.m_densifyDist=a,this.m_maxVertexInCompleteCircle=m,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&Ae(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,this.m_joins!==0,Xe()));const u=this.bufferImpl();return this.m_geometry=null,u}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const e=this.m_circleTemplateSize,t=Math.trunc((e+3)/4),s=.5*Math.PI/t;this.m_dA=s,this.m_circleTemplate=pe(_,4*t);const n=Math.cos(s),r=Math.sin(s),i=_.construct(0,1);for(let a=0;a<t;a++)this.m_circleTemplate[a+0*t].setCoords(i.y,-i.x),this.m_circleTemplate[a+1*t].setCoords(-i.x,-i.y),this.m_circleTemplate[a+2*t].setCoords(-i.y,i.x),this.m_circleTemplate[a+3*t].setCoords(i.x,i.y),i.rotateReverse(n,r)}bufferImpl(){const e=this.m_geometry.getGeometryType();if(Ce(e)){const t=new L({vd:this.m_geometry.getDescription()});return t.addSegment(this.m_geometry,!0),this.m_geometry=t,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!ge(e))return new A({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const t=new N;if(this.m_geometry.queryEnvelope(t),t.width()<=2*this.m_absDistance||t.height()<=2*this.m_absDistance)return new A({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case K.enumPoint:return this.bufferPoint();case K.enumMultiPoint:return this.bufferMultiPoint();case K.enumPolyline:return this.bufferPolyline();case K.enumPolygon:return this.bufferPolygon();case K.enumEnvelope:return this.bufferEnvelope();default:$("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const l=new O;this.m_geometry.getPointByVal(0,l);const h=new N;return this.m_geometry.queryEnvelope(h),l.setXY(h.getCenter()),this.bufferDegeneratePath(l,!0)}const e=this.m_geometry,t=this.m_geometry.getDescription();this.m_geometry=null;const s=new We(e);let n,r;n=this.m_joins===0?new je().executeMany(s,.25*this.m_densifyDist,!1,this.m_progressTracker):s,r=this.m_bRoundBuffer?new Oe().executeMany(n,null,!0,this.m_progressTracker):n;const i=new Ke(this,r,this.m_bFilter),a=new ne().executeMany(i,this.m_spatialReference,this.m_progressTracker,2),m=new te().executeMany(a,this.m_spatialReference,!1,this.m_progressTracker).next();return m!==null?m:new A({vd:t})}bufferPolygon(){if(this.m_distance===0)return this.m_geometry;this.generateCircleTemplate();const e=new te().execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;const t=this.m_geometry,s=this.bufferPolygonImpl(t,0,t.getPathCount());return new te().execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){const r=new O;this.m_geometry.getPointByVal(0,r);const i=new N;return this.m_geometry.queryEnvelope(i),r.setXY(i.getCenter()),this.bufferDegeneratePath(r,!0)}const t=new Qe(this),s=new ne().executeMany(t,this.m_spatialReference,this.m_progressTracker,2),n=new te().executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return n!==null?n:new A({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(e,t,s){const n=e,r=n.getImpl();let i=new A({vd:e.getDescription()});for(let a=t;a<s;a++){if(r.getPathSize(a)<1)continue;const m=r.calculateRingArea2D(a),l=new N;if(r.queryPathEnvelope(a,l),this.m_distance>0)if(m>0)if(this.isDegeneratePath(r,a)){const h=new O;r.getPointByVal(r.getPathStart(a),h),h.setXY(l.getCenter()),i.add(this.bufferDegeneratePath(h,!0),!1)}else{const h=new L({vd:e.getDescription()}),u=h.getImpl();if(Be(this.m_geometry,a)){const f=this.bufferConvexPath(n,a);i.add(f,!1)}else{this.bufferClosedPath(this.m_geometry,a,u,this.m_bRoundBuffer,1);const f=this.bufferCleanup(h);i.add(f,!1)}}else{if(l.width()+this.m_tolerance.total()<=2*this.m_absDistance||l.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const h=new L({vd:e.getDescription()}),u=h.getImpl();if(this.bufferClosedPath(this.m_geometry,a,u,this.m_bRoundBuffer,1),!h.isEmpty()){const f=l,c=Math.max(1,this.m_absDistance),d=f.clone();d.inflateCoords(c,c),u.addEnvelope(d,!1);const b=this.bufferCleanup(h);i.reserve(i.getPointCount()+b.getPointCount()-4),ae(b,i,d,!0)}}else if(m>0){if(l.width()+this.m_tolerance.total()<=2*this.m_absDistance||l.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const h=new L({vd:e.getDescription()}),u=h.getImpl();if(this.bufferClosedPath(this.m_geometry,a,u,this.m_bRoundBuffer,-1),!h.isEmpty()){const f=new N;u.queryLooseEnvelope(f);const c=Math.max(1,this.m_absDistance),d=f.clone();d.inflateCoords(c,c),u.addEnvelope(d,!1),ae(this.bufferCleanup(h),i,d,!0)}}else{const h=new L({vd:e.getDescription()}),u=h.getImpl();this.bufferClosedPath(this.m_geometry,a,u,this.m_bRoundBuffer,-1);const f=this.bufferCleanup(h);for(let c=0,d=f.getPathCount();c<d;c++)i.addPath(f,c,!0)}}if(this.m_distance>0)return i.getPathCount()>1?this.bufferCleanup(i):ie(i);{const a=new N;if(i.queryLooseEnvelope(a),i.isEmpty())return ie(i);{const m=Math.max(1,this.m_absDistance),l=a.clone();l.inflateCoords(m,m),i.addEnvelope(l,!1);const h=this.bufferCleanup(i);i=new A;const u=new A({vd:h.getDescription()});return ae(h,u,l,!1),ie(u)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){const t=new A({vd:e.getDescription()});return this.m_caps===0?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):this.m_caps===2?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){const s=new A({vd:e.getDescription()});return t&&this.m_joins===0||!t&&this.m_caps===0?(this.addCircle(s.getImpl(),e),this.setStrongSimple(s)):t||this.m_caps!==2?s:(this.addSquare(s.getImpl(),e),this.setStrongSimple(s))}bufferMultiPoint(){const e=new Je(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return new ne().executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new A({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(this.m_distance===0)e.addEnvelope(this.m_geometry,!1),be(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{const s=new re;this.m_geometry.queryEnvelope(s),s.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(s,!1),be(s,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(this.m_joins===1){const s=new re({copy:this.m_geometry});return s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1),e}const t=this.m_geometry.clone();if(t.width()===0||t.height()===0){if(t.width()===0&&t.height()===0){const r=new O({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,r),this.m_geometry=r,this.bufferImpl()}const s=new L({vd:this.m_geometry.getDescription()}),n=new O;return t.queryCornerByVal(0,n),s.startPathPoint(n),t.queryCornerByVal(2,n),s.lineToPoint(n),this.m_geometry=s,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();const s=e.hasAttribute(10),n=new A({vd:e.getDescription()}),r=n.getImpl();n.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));const i=new _,a=new _,m=new _,l=new _(0,0),h=new _,u=new _,f=e.getImpl(),c=e.getPathSize(t),d=e.getPathStart(t);for(let b=0,p=e.getPathSize(t);b<p;b++){const g=f.getXY(d+b),C=f.getXY(d+(b+1)%c),v=f.getXY(d+(b+2)%c);h.setSub(C,g),h.length()===0&&$("");const D=s&&!!(1&f.getAttributeAsInt(10,(b+1)%c,0));h.normalize();const x=h.clone();h.leftPerpendicularThis(),h.scale(this.m_absDistance),i.setAdd(h,g),a.setAdd(h,C),b===0?r.startPath(i):r.lineTo(i),r.lineTo(a),u.setSub(v,C),u.length()===0&&$(""),u.normalize();const M=u.clone();u.leftPerpendicularThis(),u.scale(this.m_absDistance),m.setAdd(u,C);let E=P.enumArc;const X=D?0:this.m_joins;if(X===2)E=P.enumBevel;else if(X===1){const W=-x.crossProduct(M);l.setSub(x,M),l.scale(this.m_absDistance/W),l.length()<this.m_miterLimit*this.m_absDistance?(l.addThis(C),E=P.enumMiter):E=P.enumBevel}else l.assign(C);this.addJoin(E,r,l,a,m,!1,!1)}return ie(n)}bufferPolylinePath(e,t,s){this.generateCircleTemplate();const n=e,r=n.getImpl();if(r.getPathSize(t)<1)return null;let i;if(i=this.m_bRoundBuffer?r.isClosedPathInXYPlane(t):r.isClosedPath(t),this.isDegeneratePath(r,t)&&this.m_distance>0){const l=new O;r.getPointByVal(r.getPathStart(t),l);const h=new N;return r.queryPathEnvelope(t,h),l.setXY(h.getCenter()),this.bufferDegeneratePath(l,i)}const a=new L({vd:e.getDescription()});a.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*r.getPathSize(t));const m=a.getImpl();return i?this.bufferClosedPath(n,t,m,s,1)!==2&&this.bufferClosedPath(n,t,m,s,-1):this.bufferOpenPath(n,t,m,s),this.bufferCleanup(a)}progress_(){}bufferCleanup(e,t=!1){const s=t?this.m_tolerance:this.m_smallTolerance;return Ge(e,s,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(this.m_densifyDist===0)return this.m_maxVertexInCompleteCircle;const t=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let s=4;return s=t<-1?4:2*Math.PI/Math.acos(t)+.5,s<4?s=4:s>this.m_maxVertexInCompleteCircle&&(s=this.m_maxVertexInCompleteCircle),Math.trunc(s)}addJoin(e,t,s,n,r,i,a){if(this.generateCircleTemplate(),i&&(t.startPath(n),i=!1),e===P.enumBevel)return void(a&&t.lineTo(r));if(e===P.enumMiter){const g=s.clone();return t.lineTo(g),void(a&&t.lineTo(r))}const m=new _;m.setSub(n,s),m.scale(this.m_absDistanceReversed);const l=new _;l.setSub(r,s),l.scale(this.m_absDistanceReversed);let h=Math.atan2(m.y,m.x)/this.m_dA;h<0&&(h=this.m_circleTemplate.length+h),h=this.m_circleTemplate.length-h;let u=Math.atan2(l.y,l.x)/this.m_dA;u<0&&(u=this.m_circleTemplate.length+u),u=this.m_circleTemplate.length-u,u<h&&(u+=this.m_circleTemplate.length);let f=Math.trunc(u),c=Math.ceil(h),d=this.m_circleTemplate[c%this.m_circleTemplate.length].clone();d.scaleAddThis(this.m_absDistance,s);const b=10*this.m_tolerance.total();d.sub(n).length()<b&&(c+=1),d=this.m_circleTemplate[f%this.m_circleTemplate.length].clone(),d.scaleAddThis(this.m_absDistance,s),d.sub(r).length()<b&&(f-=1);let p=f-c;p++;for(let g=0,C=c%this.m_circleTemplate.length;g<p;g++,C=(C+1)%this.m_circleTemplate.length)d=this.m_circleTemplate[C].clone(),d.scaleAddThis(this.m_absDistance,s),t.lineTo(d),this.progress_();a&&t.lineTo(r)}bufferClosedPath(e,t,s,n,r){const i=new me,a=i.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(i,a,s,n,r)}bufferClosedPathImpl(e,t,s,n,r){const i=e.getFirstVertex(e.getFirstPath(t)),a=new O;if(e.queryPoint(i,a),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),e.getPointCount(t)<2)return r<0?0:(this.m_bRoundBuffer&&this.addCircle(s,a),2);J(e.getFirstPath(t)!==Z),J(e.getFirstVertex(e.getFirstPath(t))!==Z);const m=e.getXY(e.getFirstVertex(e.getFirstPath(t))),l=new he;if(l.setShift(m.negate()),e.applyTransformation(l),n){const T=tt(e,t,r,!0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if(J(T===1),e.getPointCount(t)<2)return r<0?0:(this.addCircle(s,a),2)}const h=this.m_joins!==0&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const u=e.getFirstPath(t);let f=e.getFirstVertex(u),c=r===1?e.getPrevVertex(f):e.getNextVertex(f),d=r===1?e.getNextVertex(f):e.getPrevVertex(f),b=!0;const p=new _,g=new _,C=new _,v=new _,D=new _,x=new _,M=new _,E=new _,X=this.m_absDistance,W=e.getPathSize(u),G=new _(0,0);for(let T=0;T<W;T++){g.assign(e.getXY(d)),b&&(p.assign(e.getXY(f)),C.assign(e.getXY(c)),x.setSub(p,C),x.normalize(),E.leftPerpendicularOther(x),E.scale(X),v.setAdd(E,p));const y=h&&!!(1&e.getAttributeAsDbl(10,f,0));D.setSub(g,p),D.normalize(),M.leftPerpendicularOther(D),M.scale(X);const Y=new _;Y.setAdd(p,M);const q=x.crossProduct(D),w=x.dotProduct(D);if(q<0||w<0&&q<Math.abs(w)*Number.EPSILON*8){let B=!1;const F=y?0:this.m_joins;if(F===1){const V=-q;G.setSub(x,D),G.scale(this.m_absDistance/V),G.length()<this.m_miterLimit*this.m_absDistance&&(G.addThis(p),B=!0),this.m_bufferCommands.push(z(v,Y,G,B?P.enumMiter:P.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(z(v,Y,p,F===0?P.enumArc:P.enumBevel,this.m_bufferCommands.length+1))}else v.equals(Y)||(this.m_bufferCommands.push(se(v,p,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(se(p,Y,this.m_bufferCommands.length+1)));const S=new _;S.setAdd(g,M),this.m_bufferCommands.push(z(Y,S,p,P.enumLine,this.m_bufferCommands.length+1)),v.setCoordsPoint2D(S),E.setCoordsPoint2D(M),C.setCoordsPoint2D(p),p.setCoordsPoint2D(g),x.setCoordsPoint2D(D),c=f,f=d,b=!1,d=r===1?e.getNextVertex(f):e.getPrevVertex(f)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),l.setShift(m),s.applyTransformationToPath(l,s.getPathCount()-1),1}bufferOpenPath(e,t,s,n){if(this.m_bRoundBuffer){const y=new L({vd:e.getDescription()});return y.addPath(e,t,!1),y.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(y,0,s,n,1)}let r=0;const i=new L({vd:e.getDescription()}),a=new _(0,0);{const y=new me,Y=y.addPathFromMultiPath(e,t,!1),q=y.getFirstVertex(y.getFirstPath(Y)),w=new O;if(y.queryPoint(q,w),a.assign(w.getXY()),y.filterClosePoints(0,!1,!1,!1,-1),y.getPointCount(Y)<2)return this.m_bRoundBuffer&&this.addCircle(s,w),2;const S=y.getGeometry(y.getFirstGeometry());i.addPath(S,0,!1),r=i.getPointCount()-1,i.addSegmentsFromPath(S,0,0,S.getSegmentCountPath(0)-1,!1)}const m=new me,l=m.addPathFromMultiPath(i,0,!0);J(m.getFirstPath(l)!==Z),J(m.getFirstVertex(m.getFirstPath(l))!==Z);const h=new he;h.setShift(a.negate()),m.applyTransformation(h),this.m_bufferCommands.length=0;const u=m.getFirstPath(l),f=this.m_joins!==0&&m.getVertexDescription().hasAttribute(10);let c=m.getFirstVertex(u),d=m.getPrevVertex(c),b=m.getNextVertex(c),p=!0;const g=new _,C=new _,v=new _,D=new _,x=new _,M=new _,E=new _,X=new _,W=this.m_absDistance,G=m.getPathSize(u),T=new _(0,0);for(let y=0;y<G;y++){let Y=!1;y!==0&&y!==r||(Y=!0),C.assign(m.getXY(b)),p&&(g.assign(m.getXY(c)),v.assign(m.getXY(d)),M.setSub(g,v),M.normalize(),X.leftPerpendicularOther(M),X.scale(W),D.setAdd(X,g));const q=f&&!!(1&m.getAttributeAsDbl(10,c,0));x.setSub(C,g),x.normalize(),E.leftPerpendicularOther(x),E.scale(W);const w=new _;w.setAdd(g,E);const S=M.crossProduct(x),B=M.dotProduct(x);if(S<0||B<0&&S<Math.abs(B)*Number.EPSILON*8)if(Y)if(this.m_caps===0)this.m_bufferCommands.push(z(D,w,g,P.enumArc,this.m_bufferCommands.length+1));else if(this.m_caps===1)this.m_bufferCommands.push(z(D,w,g,P.enumLine,this.m_bufferCommands.length+1));else{const V=x.mul(this.m_absDistance).negate(),j=V.clone();V.addThis(D),j.addThis(w),this.m_bufferCommands.push(z(D,V,g,P.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(z(V,j,g,P.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(z(j,w,g,P.enumLine,this.m_bufferCommands.length+1))}else{let V=!1;const j=q?0:this.m_joins;if(j===1){const k=-S;T.setSub(M,x),T.scale(this.m_absDistance/k),T.length()<this.m_miterLimit*this.m_absDistance&&(T.addThis(g),V=!0),this.m_bufferCommands.push(z(D,w,T,V?P.enumMiter:P.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(z(D,w,g,j===0?P.enumArc:P.enumBevel,this.m_bufferCommands.length+1))}else D.equals(w)||(this.m_bufferCommands.push(se(D,g,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(se(g,w,this.m_bufferCommands.length+1)));const F=new _;F.setAdd(C,E),this.m_bufferCommands.push(z(w,F,g,P.enumLine,this.m_bufferCommands.length+1)),D.setCoordsPoint2D(F),X.setCoordsPoint2D(E),v.setCoordsPoint2D(g),g.setCoordsPoint2D(C),M.setCoordsPoint2D(x),d=c,c=b,p=!1,b=m.getNextVertex(c)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),h.setShift(a),s.applyTransformationToPath(h,s.getPathCount()-1),1}processBufferCommands(e){const t=this.cleanupBufferCommands();let s=!0,n=t+1;for(let r=t;n!==t;r=n){const i=this.m_bufferCommands[r];n=i.m_next!==-1?i.m_next:(r+1)%this.m_bufferCommands.length,i.m_type&&(s&&(e.startPath(i.m_from),s=!1),i.m_type&P.enumJoinMask?this.addJoin(i.m_type,e,i.m_center,i.m_from,i.m_to,!1,!0):e.lineTo(i.m_to))}}cleanupBufferCommands(){this.m_helperArray=pe(_,9);let e=0;for(let s=0,n=this.m_bufferCommands.length;s<n;){const r=this.m_bufferCommands[s];if(r.m_type&P.enumConnectionMask){e=s;break}s=r.m_next}let t=e+1;for(let s=e;t!==e;s=t){const n=this.m_bufferCommands[s];t=n.m_next;let r=1,i=null;for(;t!==s&&(i=this.m_bufferCommands[t],!(i.m_type&P.enumConnectionMask));)t=i.m_next,r++;r!==1&&(n.m_type&i.m_type)===P.enumLine&&(this.m_helperLine1.setStartXY(n.m_from),this.m_helperLine1.setEndXY(n.m_to),this.m_helperLine2.setStartXY(i.m_from),this.m_helperLine2.setEndXY(i.m_to),this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())===1&&(n.m_to.assign(this.m_helperArray[0]),i.m_from.assign(this.m_helperArray[0]),n.m_next=t))}return e}isDegeneratePath(e,t){if(e.getPathSize(t)===1)return!0;if(this.m_joins===0&&this.m_caps===0){const s=new N;if(e.queryPathEnvelope(t,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(this.m_joins===0&&this.m_caps===0){const t=new N;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){const s=t.getXY();if(this.m_circleTemplate.length!==0){let l=this.m_circleTemplate[0].clone();l.scaleAddThis(this.m_absDistance,s),e.startPath(l);for(let h=1,u=this.m_circleTemplate.length;h<u;h++)l=this.m_circleTemplate[h].clone(),l.scaleAddThis(this.m_absDistance,s),e.lineTo(l);return}const n=this.m_circleTemplateSize,r=Math.trunc((n+3)/4),i=.5*Math.PI/r;e.reserve(4*r);const a=Math.cos(i),m=Math.sin(i);for(let l=3;l>=0;l--){const h=_.construct(0,this.m_absDistance);switch(l){case 0:for(let u=0;u<r;u++)e.lineToCoords(h.x+s.x,h.y+s.y),h.rotateReverse(a,m);break;case 1:for(let u=0;u<r;u++)e.lineToCoords(-h.y+s.x,h.x+s.y),h.rotateReverse(a,m);break;case 2:for(let u=0;u<r;u++)e.lineToCoords(-h.x+s.x,-h.y+s.y),h.rotateReverse(a,m);break;default:e.startPathCoords(h.y+s.x,-h.x+s.y);for(let u=1;u<r;u++)h.rotateReverse(a,m),e.lineToCoords(h.y+s.x,-h.x+s.y)}this.progress_()}}addSquare(e,t){const s=new re({vd:t.getDescription()});s.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}}function ie(o){return Te(o,0),o}function be(o,e){return!!o.isEmpty()||Math.min(o.width(),o.height())>e}function Ze(o,e,t,s,n,r,i,a){const m=o.getXY(t),l=o.getXY(s);if(m.equals(l))return-1;const h=.25*i,u=.25*i,f=new _;f.setSub(l,m);const c=f.length(),d=c*c*.25,b=r*r-d;if(b<=d)return-1;const p=Math.sqrt(b);f.normalize();const g=f.clone();g.rightPerpendicularThis();const C=d/p,v=C<=u,D=_.lerp(l,m,.5),x=g.clone(),M=C-h;x.scaleAddThis(Math.max(0,M),D),g.negate().scaleAddThis(p,D);const E=3.61*Le(r-u),X=x.sub(m),W=x.sub(l);let G=!1,T=0;const y=Ne(64,0);J(a===y.length);{for(let R=o.getPrevVertexEx(s,n);R!==t;){if(o.getUserIndex(R,e)===1)return-1;if(!o.getXY(R).equals(l))break;{const U=o.getPrevVertexEx(R,n);o.removeVertex(R,!1),R=U}}const k=new _,I=m.clone();y[T++]=1;for(let R=o.getNextVertexEx(t,n);R!==s;){if(o.getUserIndex(R,e)===1)return-1;const U=o.getXY(R);if(U.equals(I)){const Ie=o.getNextVertexEx(R,n);o.removeVertex(R,!1),R=Ie;continue}y[T++]=0;const fe=new _;if(fe.setSub(U,m),fe.dotProduct(g)<0)return 0;(_.sqrDistance(U,m)>E||_.sqrDistance(U,l)>E)&&(G=!0);let ee=0;if(U.sub(m).crossProduct(X)>=0&&(ee=1),U.sub(l).crossProduct(W)<=0&&(ee|=2),ee===0)return 0;y[T-1]=ee,k.assign(I),I.assign(U),R=o.getNextVertexEx(R,n)}if(T===1)return 0;J(T<y.length),y[T++]=2}let Y=!0;for(let k=1,I=0;k<T;k++)if(y[k]!==y[k-1]&&(I++,Y=I<3&&(I===1&&y[k]===3||I===2&&y[k]===2),!Y))return 0;if(T>2&&Y&&(T===3||!G)){let k=0,I=o.getNextVertexEx(t,n);for(v||(o.setXY(I,x),I=o.getNextVertexEx(I,n));I!==s;){const R=o.getNextVertexEx(I,n);o.removeVertex(I,!1),I=R,++k}return k}if(J(T!==3),G&&T>3)return 0;const q=m.clone();let w=t;const S=m.clone();let B=1,F=-1,V=w,j=0;for(T=1;V!==s;){V=o.getNextVertexEx(V,n);const k=y[T++];if(k===0){if(V===s)break;continue}const I=o.getXY(V);if(F!==-1){if(3&(F&B&k)){o.removeVertex(w,!0),j++,w=V,S.setCoordsPoint2D(I),B=k;continue}if(B===3&&F!==0&&k!==0){if(S.setCoordsPoint2D(x),v||S.equals(q)){o.removeVertex(w,!0),j++,w=V,S.setCoordsPoint2D(I),B=k;continue}o.setXY(w,S)}}F=B,q.setCoordsPoint2D(S),w=V,B=k,S.setCoordsPoint2D(I)}return j}function $e(o,e,t,s){let n=-1;const r=new _,i=new _,a=new _;for(let m=0,l=o.getPathSize(s),h=o.getFirstVertex(s);m<l;++m){n===-1&&(o.queryXY(h,i),n=o.getPrevVertex(h),n!==-1&&(o.queryXY(n,r),a.setSub(i,r),a.normalize()));const u=o.getNextVertex(h);if(u===-1)break;const f=o.getXY(u),c=f.sub(i);c.normalize(),n!==-1&&c.dotProduct(a)<-.99&&Math.abs(c.crossProduct(a))<1e-7&&o.setUserIndex(h,e,1),n=h,h=u,r.assign(i),i.assign(f),a.assign(c)}}function et(o,e,t,s,n,r,i){const a={stack:[],error:void 0,hasError:!1};try{const m=o.getFirstPath(e),l=o.createUserIndex();ve(a,we(()=>{o.removeUserIndex(l)},!1),!1),$e(o,l,e,m);for(let h=0;h<100;++h){if(o.getPathSize(m)===0)return 1;let u=o.getFirstVertex(m),f=o.getPathSize(m);if(f<3)return 1;o.isClosedPath(m)||(f-=1);const c=64;let d=0,b=!1;for(let p=0;p<f&&u!==Z;p++){let g=0,C=u;for(let v=1,D=Math.min(c,f-p);v<D;v++)if(C=o.getNextVertexEx(C,t),v>1){const x=Ze(o,l,u,C,t,n,i,c);if(x===-1)break;g+=x,f-=x}if(d+=g,b=g>0,b){const v=o.getPrevVertexEx(u,t);if(v!==-1){u=v,f++;continue}}u=o.getNextVertexEx(u,t)}if(d===0)break}return o.filterClosePoints(r,!1,!1,!1,-1),1}catch(m){a.error=m,a.hasError=!0}finally{ke(a)}}function tt(o,e,t,s,n,r,i){return et(o,e,t,s,n,r,i)}function ae(o,e,t,s){for(let n=0,r=o.getPathCount();n<r;n++){const i=o.getXY(o.getPathStart(n));i.x!==t.xmin&&i.x!==t.xmax&&e.addPath(o,n,s)}}class st{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n,r){return this.executeManyEx(e,t,s,Number.NaN,96,n,r)}execute(e,t,s,n){Number.isFinite(s)||Q("Invalid distance for buffer operation");const r=new le([e]),i=[s],a=this.executeMany(r,t,i,!1,n).next();return a||$("null buffer output"),a}executeManyEx(e,t,s,n,r,i,a){if(s.find(m=>!Number.isFinite(m))!==void 0&&Q("Invalid distance for buffer operation"),i){const m=new xe(e,t,s,n,r,!1,a);return new ne().executeMany(m,t,a,2)}return new xe(e,t,s,n,r,!1,a)}}class xe extends H{constructor(e,t,s,n,r,i,a){super(),this.m_currentUnionEnvelope2D=new N,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=a,this.m_bufferer=new He(a),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_distances=s,this.m_maxDeviation=n,this.m_maxVerticesInFullCircle=r}tock(){return!0}getRank(){return 1}next(){{let e;for(;e=this.m_inputGeoms.next();)return ue(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.buffer(e,this.m_distances[this.m_dindex]);return null}}getGeometryID(){return this.m_index}buffer(e,t){return this.m_bufferer.buffer(e,t,this.m_spatialReference,0,0,4,this.m_maxDeviation,this.m_maxVerticesInFullCircle)}}const ce=new st;function at(o,e,t){return ce.execute(o,e,t,null)}function ot(o,e,t,s,n,r){const i=ce.executeManyEx(new le(o),e,t,s,n,r,null);return Array.from(i)}function ht(){return ce.supportsCurves()}export{je as P,at as f,ot as l,ht as x};
